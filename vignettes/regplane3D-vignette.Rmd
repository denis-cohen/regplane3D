---
title: "regplane3D: Plotting regression predictions in 3D"
author: "Denis Cohen & Nick Baumann"
date: "`r format(Sys.Date(), format='%B %d, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{regplane3D: Plotting regression predictions in 3D}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(regplane3D)
```

# The regplane3D package

The `regplane3D` package is a convenience wrapper for Karline Soetaert's
[`plot3D`](https://cran.r-project.org/web/packages/plot3D/index.html) package.
`regplane3D` uses several `plot3D` functions to produce visually appealing
three-dimensional displays of regression estimates with confidence intervals.
For example, the package can be used to  plot conditional expected values 
of an outcome variable $Z$ over the joint distribution of two continuous
predictors, $X$ and $Y$, i.e., $\mathbb{E}(Z|X,Y)$.

`regplane3D` (development version 0.1.0) consists of three functions:

1. `plane3D`: Plot a three-dimensional regression prediction with confidence intervals.
1. `twoplanes3D`: Plot a three-dimensional regression prediction with two planes, typically separated at a cut point in one of the two horizontal dimensions, with their respective confidence intervals.
1. `heatmap3D`: Auxiliary function for adding three-dimensional heatmaps to plots produced by either `plane3D` or `twoplanes3D`. These heatmaps show the joint frequency/density distribution of the model predictors represented on the horizontal axes of the plots.

# Installation

To install the latest development version of `regplane3D` from GitHub, run:

```{r, eval = FALSE}
library(devtools)
devtools::install_github("denis-cohen/regplane3D")
library(regplane3D)
```

# Prerequisites

The use of `regplane3D` functions requires that users provide the following inputs:

1. A vector containing a sequence of values for the first predictor, $X$.
1. A vector containing a sequence of values for second predictor, $Y$.
1. A matrix containing the expected values of $Z$, or an array containing the expected values as well as their lower and upper confidence interval bounds, for all combinations of the specified values for $X$ and $Y$.
1. *Optional*: A matrix containing the discretized joint density or joint frequency of $X$ and $Y$.

We illustrate how these inputs can be generated in some applied examples below.

# Using regplane3D functions

We will illustrate the use of `regplane3D`'s functions using the package's
internal data set `us`, a small data set containing information of incumbent
vote shares, approval ratings, and economic growth rates in
US Presidential Elections 1948-2004.
For a documentation of the data, run `?regplane3D::us`.

## plane3D()

A staple of introductory statistics classes is the notion that "we no longer
deal with a line in two dimensions, but with a plane in three dimensions" once
we extend the simple bivariate regression model to include an additional
predictor. Our first example uses the `plane3D()` function to illustrate
this in the context of an OLS regression of incumbent vote shares in US
Presidential Elections on incumbent approval ratings and economic growth.

### Estimation and prediction

To obtain the required inputs, we first run a linear regression model of the form
$\texttt{vote} = \beta_1 + \beta_2 \texttt{growth} + \beta_3 \texttt{approval} +\epsilon$
and save the estimation results to an object named `mod`.

```{r use-plane3D-step1}
## ---- Estimation ----
mod <- lm(vote ~ growth + approval, dat = us)
```

We then define roughly rounded ranges of our predictors `growth` and `approval`.
For the sake of convenience, we use a little auxiliary function that allows us
to round the range of a variable to a custom base value:

```{r round-range}
round_range <- function(x, base) {
  c(base * floor(min(x, na.rm = TRUE) / base),
    base * ceiling(max(x, na.rm = TRUE) / base))
}
```

We then generate sequences of `length.out = 21L` equally spaced values for each
of the two predictors and store them in the objects `growth_seq` and
`approval_seq`, respectively.

For each of the $21 \times 21$ value combinations, we then retrieve the
expected value and the lower and upper bounds of its 95% confidence interval
using the `predict.lm()` function with option `se.fit = TRUE`. At each iteration
of the nested loop, expected values are temporarily stored in
`pred_tmp$fit` and standard errors are temporarily stored in `pred_tmp$se.fit`.
We can extract the expected value and calculate the lower and upper bounds of
the 95% confidence interval at each iteration using
`pred_tmp$fit + qnorm(.025) * pred_tmp$se.fit` and
`pred_tmp$fit + qnorm(.975) * pred_tmp$se.fit`, respectively.
We subsequently store the estimate of a givern iteration in the appropriate cell
of the array `pred`.
The array is of dimensions `dim = c(21L, 21L, 3L)`.
The first dimension represents the values of `growth_seq`, the second dimension
represents the values of `approval_seq`, and the third dimension represents the
point estimates, lower confidence bounds, and upper confidence bounds.

```{r use-plane3D-step2}
## ---- Prediction ----
growth_range <- round_range(us$growth, 1)
approval_range <- round_range(us$approval, 10)
growth_seq <-
  seq(growth_range[1], growth_range[2], length.out = 21L)
approval_seq <-
  seq(approval_range[1], approval_range[2], length.out = 21L)

pred <- array(NA, dim = c(length(growth_seq), length(approval_seq), 3L))
for (growth in seq_along(growth_seq)) {
  for (approval in seq_along(approval_seq)) {
    pred_tmp <- predict.lm(
      mod,
      newdata = data.frame(growth = growth_seq[growth],
                           approval = approval_seq[approval]),
      se.fit = TRUE
    )
    pred[growth, approval,] <- c(
      pred_tmp$fit,
      pred_tmp$fit + qnorm(.025) * pred_tmp$se.fit,
      pred_tmp$fit + qnorm(.975) * pred_tmp$se.fit
    )
  }
}
```

### Plotting

Using these estimates, we can then plot our regression plane using
`plane3D()`.
We pass the inputs `z = pred`, `x = growth_seq`, and `y = approval_seq` to the
function, which contain all required information to plot the regression plane.
The point estimate of the regression line is plotted by default.
Confidence intervals are added per the option `cis = TRUE`.
For additional options, see `?plane3D`.

```{r use-plane3D-step3, fig.width=6.5, fig.height=5, out.width='80%', fig.align='center', dpi=300}
## ---- Plot ----
par(mar = c(2.1, 2.1, 4.1, 0.1))
plane3D(
  z = pred,
  x = growth_seq,
  y = approval_seq,
  zlab = "Predicted Vote Share",
  xlab = "Economic Growth",
  ylab = "Approval Rating",
  zlim = round_range(pred, 5),
  xlim = growth_range,
  ylim = approval_range,
  cis = TRUE,
  nlines = 7,
  main = "Incumbent Vote Shares, Economic \n Growth, and Approval Ratings",
  theta = -45,
  phi = 9
)
```

### Extensions

The plot can be extended using `regplane3D::heatmap3D()`, which adds a
threedimensional histogram to show the joint frequency or density distribution
of `growth` and `approval`.
Toward this end, we must first compute a matrix of the joint frequency along
discrete intervals of the two continuous predictors. For appealing visuals,
it is recommended that the partition of the discrete intervals corresponds
to the grid lines of the main plot; i.e., approval rating should be discretized
from 30 to 80 in intervals of 10 and economic growth should be discretized 
from -4 to 6 in steps of 2:

```{r use-plane3D-step4}
## Heatmap values
growth_cat <-
  cut(us$growth, breaks = seq(growth_range[1], growth_range[2], 2))
approval_cat <-
  cut(us$approval, breaks = seq(approval_range[1], approval_range[2], 10))
joint_frequency <- table(growth_cat, approval_cat)
```

We can then add the threedimensional heatmap by adding the option
`heatmap = joint_frequency` to our `plane3D()` command:

```{r use-plane3D-step5, fig.width=6.5, fig.height=5, out.width='80%', fig.align='center', dpi=300}
## ---- Plot ----
par(mar = c(2.1, 2.1, 4.1, 0.1))
plane3D(
  z = pred,
  x = growth_seq,
  y = approval_seq,
  zlab = "Predicted Vote Share",
  xlab = "Economic Growth",
  ylab = "Approval Rating",
  zlim = round_range(pred, 5),
  xlim = growth_range,
  ylim = approval_range,
  cis = TRUE,
  nlines = 7,
  main = "Incumbent Vote Shares, Economic \n Growth, and Approval Ratings",
  theta = -45,
  phi = 9,
  heatmap = joint_frequency
)
```

As the `regplane3D` package is a convenience wrapper for the `plot3D` package,
plots produced by `regplane3D` plotting functions can be supplemented with
output from `plot3D` functions (using the option `add = TRUE`).
For instance, we can add the observed values of the outcome variable 
using `plot3D::points3D()` and add text labels using `plot3D::text3D()`.

```{r use-regplane3D-step6, fig.width=6.5, fig.height=5, out.width='80%', fig.align='center', dpi=300}
## ---- Plot ----
par(mar = c(2.1, 2.1, 4.1, 0.1))
plane3D(
  z = pred,
  x = growth_seq,
  y = approval_seq,
  zlab = "Predicted Vote Share",
  xlab = "Economic Growth",
  ylab = "Approval Rating",
  zlim = round_range(pred, 5),
  xlim = growth_range,
  ylim = approval_range,
  cis = TRUE,
  nlines = 7,
  main = "Incumbent Vote Shares, Economic \n Growth, and Approval Ratings",
  theta = -45,
  phi = 9,
  heatmap = joint_frequency
)
plot3D::points3D(
  z = us$vote,
  x = us$growth,
  y = us$approval,
  add = TRUE,
  col = adjustcolor("black", alpha.f = .3),
  pch = 19
)
plot3D::text3D(
  z = us$vote + 2.5,
  x = us$growth,
  y = us$approval,
  labels = us$incumbent,
  add = TRUE,
  cex = 0.6
)
```

## twoplanes3D()

The `twoplanes3D()` function extends the functionality of `plane3D()` to
accommodate two separate planes. These are typically required when the
model prediction is distinct to specific value ranges separated by a cut point
in one of the two horizontal dimensions (akin to a discontinuity or binary
spline).

We showcase the function by replicating the empirical example introduced
above, now with distinct regression predictions for incumbent presidents
with above-average and below-average approval ratings, respectively.

Estimation and prediction are not a bit more intricate. We interact both model
predictors with the binary indicator `approval_above_mean`. We then store
expected values and confidence bounds across 21 values `growth_range` and
21 values ranging from `min(centered_approval)` up to the cutpoint of
0 in `pred[, , 1, ]` for the prediction with below-average approval ratings. 
Analogously, we store this information for the prediction with above-average
approval ratings in `pred[, , 2, ]`, where the 21 values of `centered_approval`
now range from the cut point of up to `abs(min(centered_approval))` to provide
for a symmetrical value range and display.

### Estimation and prediction

```{r use-twoplanes3D-step1}
## ---- Estimation ----
mod <-
  lm(vote ~
       growth +
       centered_approval +
       approval_above_mean +
       growth:approval_above_mean +
       centered_approval:approval_above_mean,
     dat = us)

## ---- Prediction ----
approval_cut_point <- 0L
growth_range <- round_range(us$growth, 1)
approval_range <- round_range(us$centered_approval, 10)
approval_above_mean_vals <- c(0, 1)
growth_seq <-
  seq(growth_range[1], growth_range[2], length.out = 21L)
approval_seq <-
  seq(approval_range[1], approval_cut_point, length.out = 21L)

pred <- array(NA, dim = c(length(growth_seq), length(approval_seq), 2L, 3L))
for (growth in seq_along(growth_seq)) {
  for (centered_approval in seq_along(approval_seq)) {
    for (approval_above_mean in seq_along(approval_above_mean_vals)) {
      pred_tmp <- predict.lm(
        mod,
        newdata = data.frame(
          growth = growth_seq[growth],
          centered_approval = approval_seq[centered_approval] -
            min(approval_seq) *
            approval_above_mean_vals[approval_above_mean],
          approval_above_mean = approval_above_mean_vals[approval_above_mean]
        ),
        se.fit = TRUE
      )
      pred[growth, centered_approval, approval_above_mean,] <-
        c(
          pred_tmp$fit,
          pred_tmp$fit + qnorm(.025) * pred_tmp$se.fit,
          pred_tmp$fit + qnorm(.975) * pred_tmp$se.fit
        )
    }
  }
}
```

### Plotting

Plotting with `twoplanes3D()` works the same way as with `plane3D()`, except
we now must provide the $x$, $y$ and $z$ values separately for both planes.
For this, we use the inputs `x` and `x2`, `y` and `y2`, as well as `z` and `z2`.
Extensions can be added as with `plane3D()`.

```{r use-twoplanes3D-step2, fig.width=6.5, fig.height=5, out.width='80%', fig.align='center', dpi=300}
## ---- Plot ----
par(mar = c(2.1, 2.1, 4.1, 0.1))
twoplanes3D(
  z = pred[, , 1, ],
  x = growth_seq,
  y = approval_seq,
  z2 = pred[, , 2, ],
  x2 = growth_seq ,
  y2 = approval_seq - min(approval_seq),
  zlab = "Predicted Vote Share",
  xlab = "Economic Growth",
  ylab = "Approval Rating \n Above & Below Average",
  zlim = round_range(pred, 5),
  xlim = growth_range,
  ylim = c(min(approval_seq), - min(approval_seq)),
  cis = TRUE,
  nlines = 7,
  main = "Incumbent Vote Shares, Economic \n Growth, and Approval Ratings",
  theta = -55,
  phi = 9
)
```
